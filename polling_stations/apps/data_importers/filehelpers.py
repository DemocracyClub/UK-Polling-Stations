import csv
import fnmatch
import json
import os
import shapefile
import tempfile
import zipfile

from collections import namedtuple

from django.contrib.gis.gdal import DataSource


def recursive_find(path, pattern):
    matches = []
    for root, dirnames, filenames in os.walk(path):
        for filename in fnmatch.filter(filenames, pattern):
            matches.append(os.path.join(root, filename))
    return matches


class CsvHelper:
    """
    Helper class for reading data from CSV files
    """

    def __init__(self, filepath, encoding="utf-8", delimiter=","):
        self.filepath = filepath
        self.encoding = encoding
        self.delimiter = delimiter

    def get_features(self):
        file = open(self.filepath, "rt", encoding=self.encoding)
        reader = csv.reader(file, delimiter=self.delimiter)
        header = next(reader)

        # mimic the data structure generated by ffs so existing import
        # scripts don't break

        # fmt: off
        replace = {
            " ": "_",
            "-": "_",
            ".": "_",
            "(": "",
            ")": "",
            "/": "_",
            "\\": "_",
        }
        # fmt: on

        clean = []
        for s in header:
            s = s.strip().lower()
            for k, v in replace.items():
                s = s.replace(k, v)
            while "__" in s:
                s = s.replace("__", "_")
            clean.append(s)
        RowKlass = namedtuple("RowKlass", clean)

        data = []
        for row in map(RowKlass._make, reader):
            data.append(row)

        file.close()
        return data


class ShpHelper:
    """
    Helper class for reading geographic data from ESRI SHP files
    """

    def __init__(self, filepath, zip=False, encoding="utf-8"):
        self.filepath = filepath
        self.zip = zip
        self.encoding = encoding

    def get_features(self):
        # If our shapefile is in a zip, extract it
        # otherwise, we can read it directly
        if self.zip:
            zip_file = zipfile.ZipFile(self.filepath, "r")
            tmpdir = tempfile.mkdtemp()
            zip_file.extractall(tmpdir)

            shp_files = recursive_find(tmpdir, "*.shp")
            if len(shp_files) != 1:
                raise ValueError("Found %i shapefiles in archive" % len(shp_files))
            shp_file = shp_files[0]

            sf = shapefile.Reader(shp_file, encoding=self.encoding)
            return sf.shapeRecords()
        else:
            sf = shapefile.Reader(self.filepath, encoding=self.encoding)
            return sf.shapeRecords()


class GeoJsonHelper:
    """
    Helper class for reading geographic data from GeoJSON files
    """

    def __init__(self, filepath):
        self.filepath = filepath

    def get_features(self):
        geometries = json.load(open(self.filepath))
        return geometries["features"]


class JsonHelper:
    """
    Helper class for reading data from JSON files
    """

    def __init__(self, filepath):
        self.filepath = filepath

    def get_features(self):
        return json.load(open(self.filepath))


class KmlHelper:
    """
    Helper class for reading geographic data from KML/KMZ files
    """

    def __init__(self, filepath):
        self.filepath = filepath

    def parse_features(self, kml):
        ds = DataSource(kml)
        return ds[0]

    def get_features(self):
        if not self.filepath.endswith(".kmz"):
            return self.parse_features(self.filepath)

        # It's a .kmz file
        # Because the C lib that the Django DataSource is wrapping
        # expects a file on disk, let's extract the KML to a tmpfile
        kmz = zipfile.ZipFile(self.filepath, "r")
        kmlfile = kmz.open("doc.kml", "r")

        with tempfile.NamedTemporaryFile() as tmp:
            tmp.write(kmlfile.read())
            data = self.parse_features(tmp.name)
            tmp.close()
            return data


class FileHelperFactory:
    """
    Factory class for creating file helper objects.

    If we add helper classes for more file types,
    add an extra case to create()
    """

    @staticmethod
    def create(filetype, filepath, options):
        if filetype == "shp":
            return ShpHelper(filepath, zip=False, encoding=options["shp_encoding"])
        elif filetype == "shp.zip":
            return ShpHelper(filepath, zip=True, encoding=options["shp_encoding"])
        elif filetype == "kml":
            return KmlHelper(filepath)
        elif filetype == "geojson":
            return GeoJsonHelper(filepath)
        elif filetype == "json":
            return JsonHelper(filepath)
        elif filetype == "csv":
            return CsvHelper(
                filepath, options["csv_encoding"], options["csv_delimiter"]
            )
        else:
            raise ValueError("Unexpected file type: %s" % (filetype))
